<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Texas Hold'em World</title>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      background: #0b1020;
      color: #f5f5f5;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .container {
      flex: 1;
      width: 100%;
      max-width: 1100px;
      margin: 0 auto;
      padding: 14px 20px;
      display: flex;
      flex-direction: column;
    }

    h1 {
      text-align: center;
      margin: 0 0 2px 0;
      font-size: clamp(18px, 2.5vw, 26px);
      letter-spacing: 0.5px;
    }

    .subtitle {
      text-align: center;
      font-size: 15px;
      color: #c0c0c0;
      margin-bottom: 14px;
    }

    .disclaimer {
      text-align: center;
      font-size: 12.5px;
      color: #ffd24c;
      background: rgba(255, 210, 76, 0.08);
      border: 1px solid rgba(255, 210, 76, 0.3);
      border-radius: 6px;
      padding: 7px 14px;
      margin-bottom: 12px;
      letter-spacing: 0.2px;
      line-height: 1.6;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding: 8px 14px;
      background: #141a30;
      border-radius: 8px;
      border: 1px solid #1e2a48;
    }

    .top-bar span {
      font-size: 14px;
      font-weight: 600;
    }

    button {
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #4dd0e1;
      color: #0b1020;
      font-weight: bold;
      transition: opacity 0.15s, transform 0.1s;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    button:hover:enabled {
      opacity: 0.88;
      transform: translateY(-1px);
    }

    .board {
      text-align: center;
      margin-bottom: 14px;
      padding: 12px;
      background: #141a30;
      border-radius: 8px;
      border: 1px solid #1e2a48;
    }

    .board-title {
      font-size: 13px;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #8899bb;
    }

    .cards {
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .card {
      min-width: 44px;
      padding: 8px 10px;
      border-radius: 8px;
      background: #1b2238;
      text-align: center;
      font-size: 20px;
      border: 1px solid #2a3555;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    .players-row-top,
    .players-row-bottom {
      display: flex;
      justify-content: center;
      gap: 14px;
      margin-bottom: 14px;
      flex-wrap: wrap;
    }

    .player {
      background: #141a30;
      border: 1px solid #1e2a48;
      border-radius: 10px;
      padding: 12px 14px;
      flex: 1;
      min-width: 180px;
      max-width: 240px;
      transition: box-shadow 0.2s;
    }

    .player.me {
      border: 1.5px solid #4dd0e1;
      box-shadow: 0 0 14px rgba(77, 208, 225, 0.4);
      min-width: 220px;
    }

    .player-header {
      font-weight: bold;
      margin-bottom: 6px;
      color: #ffffff;
      font-size: 14px;
      border-bottom: 1px solid #1e2a48;
      padding-bottom: 5px;
    }

    .player-cards {
      display: flex;
      gap: 8px;
      margin-bottom: 6px;
    }

    .info-line {
      font-size: 12px;
      color: #d0d0d0;
      margin-bottom: 2px;
      line-height: 1.5;
    }

    .info-line.chips {
      color: #ffd24c;
      font-weight: 600;
    }

    .info-line.bet {
      color: #aac4ff;
    }

    .info-line.status {
      color: #c0c0c0;
    }

    .info-line.handType {
      color: #9fa8da;
      font-weight: 600;
    }

    .winner {
      color: #ffd24c;
      font-weight: bold;
    }

    .action-bar {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .action-bar button {
      padding: 10px 24px;
      font-size: 15px;
      border-radius: 8px;
      min-width: 130px;
    }

    .action-bar button:nth-child(1) { background: #4dd0e1; }
    .action-bar button:nth-child(2) { background: #66bb6a; }
    .action-bar button:nth-child(3) { background: #ef5350; }

    .status-bar {
      margin-top: 4px;
      text-align: center;
      font-size: 14px;
      color: #ffffff;
      background: #141a30;
      border: 1px solid #1e2a48;
      border-radius: 8px;
      padding: 10px 14px;
      min-height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Copyright Footer */
    .site-footer {
      text-align: center;
      padding: 12px 16px;
      background: #080d1a;
      border-top: 1px solid #1e2a48;
      font-size: 12px;
      color: #6a7a99;
      letter-spacing: 0.3px;
    }

    .site-footer a {
      color: #4dd0e1;
      text-decoration: none;
    }

    .site-footer a:hover {
      text-decoration: underline;
    }

    /* ğŸ å½©è›‹æŒ‰é’® */
    .surprise-btn {
      position: fixed;
      right: 16px;
      bottom: 54px;
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 999px;
      background: #ffd24c;
      color: #0b1020;
      box-shadow: 0 0 12px rgba(255,210,76,0.7);
      z-index: 9999;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }

    .surprise-btn:hover {
      transform: translateY(-2px);
    }

    /* å½©è›‹å¼¹å±‚é®ç½© */
    .surprise-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9998;
    }

    .surprise-modal.hidden {
      display: none;
    }

    /* å½©è›‹å¡ç‰‡ */
    .surprise-card {
      background: #141a30;
      border: 1px solid #4dd0e1;
      padding: 22px 24px;
      border-radius: 14px;
      width: 340px;
      text-align: center;
      box-shadow: 0 0 24px rgba(77,208,225,0.5);
      animation: pop 0.25s ease-out;
    }

    .surprise-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #ffd24c;
    }

    .surprise-text {
      font-size: 14px;
      line-height: 1.7;
      margin-bottom: 14px;
      color: #ffffff;
    }

    .close-btn {
      background: #4dd0e1;
      color: #0b1020;
      font-weight: bold;
      padding: 7px 16px;
      border-radius: 6px;
      cursor: pointer;
      border: none;
    }

    .snake-wrap {
      display: flex;
      justify-content: center;
      text-align: center;
      margin-top: 6px;
      margin-bottom: 8px;
      opacity: 0.95;
      pointer-events: none;
    }

    .snake {
      width: 180px;
    }

    @keyframes pop {
      from { transform: scale(0.90); opacity: 0; }
      to   { transform: scale(1);    opacity: 1; }
    }
  </style>
</head>
<body>

<div class="container">
  <h1>Welcome to the world of Texas Hold'em!</h1>

  <div class="disclaimer">
    æœ¬ç½‘ç«™æ¸¸æˆä»…ä¾›å¨±ä¹ä¸è§„åˆ™æŠ€å·§å­¦ä¹ ï¼Œä¸å«ä»»ä½•çœŸå®è´§å¸ã€ç›ˆåˆ©æˆ–èµŒåšæ€§è´¨ã€‚
    &nbsp;|&nbsp; For entertainment & skill training only â€” no real money, no gambling.
  </div>

  <div class="top-bar">
    <span id="streetLabel">é˜¶æ®µï¼š-</span>
    <span id="potLabel">åº•æ± ï¼š0</span>
    <button id="newRoundBtn">ç‚¹å‡»å¼€å§‹</button>
  </div>

  <div class="board">
    <div class="board-title">å…¬å…±ç‰Œ Community Cards</div>
    <div class="cards" id="communityCards"></div>
  </div>

  <div class="players-row-top">
    <div class="player" data-player-index="1">
      <div class="player-header" data-role="title">ç©å®¶ 2</div>
      <div class="player-cards" data-role="cards"></div>
      <div class="info-line chips" data-role="chips">ç­¹ç : 1000</div>
      <div class="info-line bet" data-role="bet">æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š0</div>
      <div class="info-line status" data-role="status">çŠ¶æ€: ç­‰å¾…</div>
      <div class="info-line handType" data-role="handType">ç‰Œå‹ï¼š-</div>
    </div>
    <div class="player" data-player-index="2">
      <div class="player-header" data-role="title">ç©å®¶ 3</div>
      <div class="player-cards" data-role="cards"></div>
      <div class="info-line chips" data-role="chips">ç­¹ç : 1000</div>
      <div class="info-line bet" data-role="bet">æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š0</div>
      <div class="info-line status" data-role="status">çŠ¶æ€: ç­‰å¾…</div>
      <div class="info-line handType" data-role="handType">ç‰Œå‹ï¼š-</div>
    </div>
    <div class="player" data-player-index="3">
      <div class="player-header" data-role="title">ç©å®¶ 4</div>
      <div class="player-cards" data-role="cards"></div>
      <div class="info-line chips" data-role="chips">ç­¹ç : 1000</div>
      <div class="info-line bet" data-role="bet">æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š0</div>
      <div class="info-line status" data-role="status">çŠ¶æ€ï¼šç­‰å¾…</div>
      <div class="info-line handType" data-role="handType">ç‰Œå‹ï¼š-</div>
    </div>
  </div>

  <div class="players-row-bottom">
    <div class="player me" data-player-index="0">
      <div class="player-header" data-role="title">ç©å®¶ 1ï¼ˆKaiï¼‰</div>
      <div class="player-cards" data-role="cards"></div>
      <div class="info-line chips" data-role="chips">ç­¹ç : 1000</div>
      <div class="info-line bet" data-role="bet">æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š0</div>
      <div class="info-line status" data-role="status">çŠ¶æ€ï¼šç­‰å¾…</div>
      <div class="info-line handType" data-role="handType">ç‰Œå‹ï¼š-</div>
    </div>
  </div>

  <div class="action-bar">
    <button id="btnCall">è·Ÿæ³¨ / çœ‹ç‰Œ</button>
    <button id="btnRaise">åŠ æ³¨ (+20)</button>
    <button id="btnFold">å¼ƒç‰Œ</button>
  </div>

  <div class="status-bar" id="statusBar">
    ç‚¹å‡»ã€Œå¼€å§‹æ–°å±€ã€å¼€å§‹æ¸¸æˆï¼Œä½ æ§åˆ¶ç©å®¶ 1ã€‚
  </div>
</div>

<!-- Copyright Footer -->
<footer class="site-footer">
  &copy; 2025 Guanyu Wu. All rights reserved. &nbsp;|&nbsp; 
</footer>

<script>
  // ---------- ç‰Œä¸ç‰Œå‹åˆ¤æ–­ï¼ˆå¯¹åº” Python ç‰ˆ create_deck / evaluate_*ï¼‰ ----------

  const SUITS = ["â™ ", "â™¥", "â™¦", "â™£"];
  const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A"];
  const RANK_VALUE = {};
  RANKS.forEach((r, i) => { RANK_VALUE[r] = i + 2; });

  const HAND_CATEGORY_NAME = {
    8: "åŒèŠ±é¡º",
    7: "å››æ¡",
    6: "è‘«èŠ¦",
    5: "åŒèŠ±",
    4: "é¡ºå­",
    3: "ä¸‰æ¡",
    2: "ä¸¤å¯¹",
    1: "ä¸€å¯¹",
    0: "é«˜ç‰Œ",
  };

  function createDeck() {
    const deck = [];
    for (const s of SUITS) {
      for (const r of RANKS) {
        deck.push({rank: r, suit: s});
      }
    }
    return deck;
  }

  function shuffle(deck) {
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
  }

  function cardStr(card) {
    return card.rank + card.suit;
  }

  function evaluate5cards(cards5) {
    const ranks = cards5.map(c => RANK_VALUE[c.rank]).sort((a, b) => b - a);
    const suits = cards5.map(c => c.suit);
    const counts = {};
    ranks.forEach(v => { counts[v] = (counts[v] || 0) + 1; });

    const countRank = Object.entries(counts)
      .map(([v, c]) => [parseInt(v), c])
      .sort((a, b) => {
        if (b[1] !== a[1]) return b[1] - a[1];
        return b[0] - a[0];
      });

    const isFlush = new Set(suits).size === 1;
    const uniqueRanks = [...new Set(ranks)].sort((a, b) => b - a);
    let isStraight = false;
    let highCard = Math.max(...uniqueRanks);

    if (uniqueRanks.length === 5 && uniqueRanks[0] - uniqueRanks[4] === 4) {
      isStraight = true;
      highCard = uniqueRanks[0];
    }
    const setRanks = new Set(uniqueRanks);
    if (setRanks.size === 5 &&
      setRanks.has(14) &&
      setRanks.has(5) &&
      setRanks.has(4) &&
      setRanks.has(3) &&
      setRanks.has(2)) {
      isStraight = true;
      highCard = 5;
    }

    if (isStraight && isFlush) {
      return [8, [highCard]];
    }
    if (countRank[0][1] === 4) {
      const four = countRank[0][0];
      const kicker = ranks.find(v => v !== four);
      return [7, [four, kicker]];
    }
    if (countRank[0][1] === 3 && countRank[1][1] === 2) {
      const three = countRank[0][0];
      const pair = countRank[1][0];
      return [6, [three, pair]];
    }
    if (isFlush) {
      return [5, [...ranks].sort((a, b) => b - a)];
    }
    if (isStraight) {
      return [4, [highCard]];
    }
    if (countRank[0][1] === 3) {
      const three = countRank[0][0];
      const kickers = [...new Set(ranks.filter(v => v !== three))].sort((a, b) => b - a);
      return [3, [three, ...kickers]];
    }
    if (countRank[0][1] === 2 && countRank[1][1] === 2) {
      const highPair = Math.max(countRank[0][0], countRank[1][0]);
      const lowPair = Math.min(countRank[0][0], countRank[1][0]);
      const kicker = ranks.find(v => v !== highPair && v !== lowPair);
      return [2, [highPair, lowPair, kicker]];
    }
    if (countRank[0][1] === 2) {
      const pair = countRank[0][0];
      const kickers = [...new Set(ranks.filter(v => v !== pair))].sort((a, b) => b - a);
      return [1, [pair, ...kickers]];
    }
    return [0, [...ranks].sort((a, b) => b - a)];
  }

  function compareHands(h1, h2) {
    if (h1[0] !== h2[0]) return h1[0] - h2[0];
    const a = h1[1];
    const b = h2[1];
    const len = Math.max(a.length, b.length);
    for (let i = 0; i < len; i++) {
      const va = a[i] || 0;
      const vb = b[i] || 0;
      if (va !== vb) return va - vb;
    }
    return 0;
  }

  function evaluate7cards(cards7) {
    let best = null;
    const n = cards7.length;
    for (let a = 0; a < n; a++) {
      for (let b = a + 1; b < n; b++) {
        for (let c = b + 1; c < n; c++) {
          for (let d = c + 1; d < n; d++) {
            for (let e = d + 1; e < n; e++) {
              const comb = [cards7[a], cards7[b], cards7[c], cards7[d], cards7[e]];
              const val = evaluate5cards(comb);
              if (!best || compareHands(val, best) > 0) {
                best = val;
              }
            }
          }
        }
      }
    }
    return best;
  }

  // ---------- æ¸¸æˆçŠ¶æ€ ----------

  const NUM_PLAYERS = 4;
  const SMALL_BLIND = 10;
  const BIG_BLIND = 20;

  let deck = [];
  let playersCards = [];
  let communityCards = [];
  let chips = new Array(NUM_PLAYERS).fill(1000);
  let inHand = new Array(NUM_PLAYERS).fill(true);
  let bets = new Array(NUM_PLAYERS).fill(0);
  let totalBets = new Array(NUM_PLAYERS).fill(0);
  let pot = 0;
  let currentBet = 0;
  let dealerIndex = -1;
  let street = "preflop";
  let handActive = false;
  let revealAll = false;

  const streetNames = {
    "preflop": "Preflop",
    "flop": "Flop",
    "turn": "Turn",
    "river": "River",
    "end": "ç»“æŸ",
  };

  function qs(selector) { return document.querySelector(selector); }

  function playerElements(i) {
    const root = document.querySelector(`.player[data-player-index="${i}"]`);
    return {
      root,
      title: root.querySelector('[data-role="title"]'),
      cards: root.querySelector('[data-role="cards"]'),
      chips: root.querySelector('[data-role="chips"]'),
      bet: root.querySelector('[data-role="bet"]'),
      status: root.querySelector('[data-role="status"]'),
      handType: root.querySelector('[data-role="handType"]'),
    };
  }

  function renderCommunity() {
    const board = qs('#communityCards');
    board.innerHTML = "";
    for (let i = 0; i < 5; i++) {
      const div = document.createElement('div');
      div.className = 'card';
      if (i < communityCards.length) {
        div.textContent = cardStr(communityCards[i]);
      } else {
        div.textContent = "ğŸ‚ ";
      }
      board.appendChild(div);
    }
  }

  function renderPlayers() {
    for (let i = 0; i < NUM_PLAYERS; i++) {
      const elems = playerElements(i);
      let titleText;
      if (i === 0) titleText = "ç©å®¶ 1ï¼ˆMeï¼‰";
      else titleText = `ç©å®¶ ${i + 1}`;
      if (i === dealerIndex) titleText += " (åº„)";
      elems.title.textContent = titleText;

      elems.cards.innerHTML = "";
      const showCards = (i === 0) || revealAll;
      if (inHand[i] && playersCards[i].length === 2) {
        for (let j = 0; j < 2; j++) {
          const div = document.createElement('div');
          div.className = 'card';
          if (showCards) {
            div.textContent = cardStr(playersCards[i][j]);
          } else {
            div.textContent = "ğŸ‚ ";
          }
          elems.cards.appendChild(div);
        }
      } else {
        for (let j = 0; j < 2; j++) {
          const div = document.createElement('div');
          div.className = 'card';
          div.textContent = "ğŸ‚ ";
          elems.cards.appendChild(div);
        }
      }

      elems.chips.textContent = `ç­¹ç ï¼š${chips[i]}`;
      elems.bet.textContent = `æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š${totalBets[i]}`;
    }
    qs('#potLabel').textContent = `åº•æ± ï¼š${pot}`;
    qs('#streetLabel').textContent = `é˜¶æ®µï¼š${streetNames[street] || "-"}`;
  }

  function setStatusBar(text) {
    qs('#statusBar').textContent = text;
  }

  function enableActionButtons(enable) {
    ['#btnCall', '#btnRaise', '#btnFold'].forEach(id => {
      qs(id).disabled = !enable;
    });
  }

  function resetForNewHand() {
    deck = createDeck();
    shuffle(deck);
    playersCards = Array.from({length: NUM_PLAYERS}, () => []);
    communityCards = [];
    bets = new Array(NUM_PLAYERS).fill(0);
    totalBets = new Array(NUM_PLAYERS).fill(0);
    pot = 0;
    currentBet = 0;
    street = "preflop";
    handActive = true;
    revealAll = false;
    inHand = chips.map(c => c > 0);
  }

  function dealHoleCards() {
    for (let r = 0; r < 2; r++) {
      for (let i = 0; i < NUM_PLAYERS; i++) {
        if (inHand[i]) {
          playersCards[i].push(deck.pop());
        }
      }
    }
  }

  function postBlinds() {
    const sb = (dealerIndex + 1) % NUM_PLAYERS;
    const bb = (dealerIndex + 2) % NUM_PLAYERS;

    for (let i = 0; i < NUM_PLAYERS; i++) {
      const elems = playerElements(i);
      if (inHand[i]) {
        elems.status.textContent = "çŠ¶æ€ï¼šåœ¨å±€ä¸­";
      } else {
        elems.status.textContent = "çŠ¶æ€ï¼šç­¹ç è€—å°½";
      }
      elems.handType.textContent = "ç‰Œå‹ï¼š-";
      elems.handType.classList.remove('winner');
    }

    takeBet(sb, SMALL_BLIND);
    playerElements(sb).status.textContent = "çŠ¶æ€ï¼šå°ç›²æ³¨";

    takeBet(bb, BIG_BLIND);
    playerElements(bb).status.textContent = "çŠ¶æ€ï¼šå¤§ç›²æ³¨";

    currentBet = BIG_BLIND;
  }

  function takeBet(player, amount) {
    if (!inHand[player]) return;
    if (amount <= 0) return;
    const actual = Math.min(amount, chips[player]);
    if (actual <= 0) return;
    chips[player] -= actual;
    bets[player] += actual;
    totalBets[player] += actual;
    pot += actual;
    if (chips[player] === 0) {
      playerElements(player).status.textContent = "çŠ¶æ€ï¼šå…¨ä¸‹";
    }
    playerElements(player).bet.textContent = `æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š${totalBets[player]}`;
    playerElements(player).chips.textContent = `ç­¹ç ï¼š${chips[player]}`;
    qs('#potLabel').textContent = `åº•æ± ï¼š${pot}`;
  }

  function newRound() {
    if (handActive) return;
    dealerIndex = (dealerIndex + 1) % NUM_PLAYERS;
    resetForNewHand();
    dealHoleCards();
    renderCommunity();
    renderPlayers();

    postBlinds();
    renderPlayers();
    enableActionButtons(true);
    qs('#newRoundBtn').disabled = true;
    street = "preflop";
    qs('#streetLabel').textContent = `é˜¶æ®µï¼š${streetNames[street]}`;
    setStatusBar("æ–°å±€å¼€å§‹ï¼šPreflopï¼Œè½®åˆ°ä½ æ“ä½œã€‚");
  }

  function advanceStreet() {
    bets = new Array(NUM_PLAYERS).fill(0);
    currentBet = 0;

    if (street === "preflop") {
      street = "flop";
      while (communityCards.length < 3) {
        communityCards.push(deck.pop());
      }
    } else if (street === "flop") {
      street = "turn";
      if (communityCards.length < 4) {
        communityCards.push(deck.pop());
      }
    } else if (street === "turn") {
      street = "river";
      if (communityCards.length < 5) {
        communityCards.push(deck.pop());
      }
    }

    renderCommunity();
    renderPlayers();
    setStatusBar(`${streetNames[street]} é˜¶æ®µï¼Œè½®åˆ°ä½ æ“ä½œã€‚`);
    enableActionButtons(true);
  }

  function revealRemainingBoard() {
    while (communityCards.length < 5 && deck.length > 0) {
      communityCards.push(deck.pop());
    }
    renderCommunity();
  }

  function awardPot(winners) {
    if (!winners || winners.length === 0 || pot <= 0) return;
    const share = Math.floor(pot / winners.length);
    winners.forEach(w => { chips[w] += share; });
    pot = 0;
    qs('#potLabel').textContent = `åº•æ± ï¼š${pot}`;
    renderPlayers();
  }

  function endHand() {
    handActive = false;
    enableActionButtons(false);
    qs('#newRoundBtn').disabled = false;
    street = "end";
    qs('#streetLabel').textContent = `é˜¶æ®µï¼š${streetNames[street]}`;
  }

  function doShowdown() {
    revealAll = true;
    renderCommunity();
    renderPlayers();

    const bestValues = [];
    const alive = [];
    for (let i = 0; i < NUM_PLAYERS; i++) {
      if (inHand[i] && playersCards[i].length === 2) {
        const val = evaluate7cards([...playersCards[i], ...communityCards]);
        bestValues.push(val);
        alive.push(i);
      }
    }

    if (alive.length === 0) {
      setStatusBar("æ— äººè·èƒœï¼Œåº•æ± ä½œåºŸã€‚");
      endHand();
      return;
    }

    let maxVal = bestValues[0];
    let winners = [alive[0]];
    for (let k = 1; k < alive.length; k++) {
      const cmp = compareHands(bestValues[k], maxVal);
      if (cmp > 0) {
        maxVal = bestValues[k];
        winners = [alive[k]];
      } else if (cmp === 0) {
        winners.push(alive[k]);
      }
    }

    awardPot(winners);

    for (let idx = 0; idx < alive.length; idx++) {
      const pIndex = alive[idx];
      const v = bestValues[idx];
      const elems = playerElements(pIndex);
      const category = v[0];
      let extra = "";
      if (winners.includes(pIndex)) {
        extra = winners.length === 1 ? "  â† èƒœè€…!" : "  â† å¹³å±€";
        elems.handType.classList.add('winner');
      }
      elems.handType.textContent = `ç‰Œå‹ï¼š${HAND_CATEGORY_NAME[category] || "æœªçŸ¥"}${extra}`;
    }

    if (winners.length === 1) {
      const w = winners[0];
      const who = (w === 0) ? "ä½ " : `ç©å®¶ ${w + 1}`;
      setStatusBar(`æ‘Šç‰Œç»“æœï¼š${who} ä»¥ ${HAND_CATEGORY_NAME[maxVal[0]]} è·èƒœã€‚`);
    } else {
      const names = winners.map(w => (w === 0 ? "ä½ " : `ç©å®¶ ${w + 1}`)).join("ï¼Œ");
      setStatusBar(`æ‘Šç‰Œç»“æœï¼š${names} ä»¥ ${HAND_CATEGORY_NAME[maxVal[0]]} å¹³åˆ†åº•æ± ã€‚`);
    }

    endHand();
  }

  function actionCallOrCheck() {
    if (!handActive || !inHand[0]) return;
    const toCall = currentBet - bets[0];
    const statusElem = playerElements(0).status;
    if (toCall <= 0) {
      statusElem.textContent = "çŠ¶æ€ï¼šè¿‡ç‰Œ";
    } else {
      statusElem.textContent = `çŠ¶æ€ï¼šè·Ÿæ³¨ ${toCall}`;
      takeBet(0, toCall);
      playerElements(0).bet.textContent = `æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š${totalBets[0]}`;
      playerElements(0).chips.textContent = `ç­¹ç ï¼š${chips[0]}`;
    }
    renderPlayers();
    afterPlayerAction();
  }

  function actionRaise() {
    if (!handActive || !inHand[0]) return;
    const raiseAmount = 20;
    const targetBet = currentBet + raiseAmount;
    const alreadyPut = bets[0];
    let toPay = targetBet - bets[0];
    if (chips[0] <= 0) return;
    if (toPay <= 0) return;
    if (toPay > chips[0]) {
      toPay = chips[0];
    }
   playerElements(0).status.textContent = "çŠ¶æ€ï¼šåŠ æ³¨";
currentBet = targetBet;
takeBet(0, toPay);
playerElements(0).bet.textContent = `æœ¬å±€ç´¯è®¡ä¸‹æ³¨ï¼š${totalBets[0]}`;
playerElements(0).chips.textContent = `ç­¹ç ï¼š${chips[0]}`;
afterPlayerAction();
  }

  function actionFold() {
    if (!handActive || !inHand[0]) return;
    inHand[0] = false;
    playerElements(0).status.textContent = "çŠ¶æ€ï¼šå¼ƒç‰Œ";
    enableActionButtons(false);
    revealRemainingBoard();
    doShowdown();
  }

  function estimateWinProbability(idx, numOpponents, numSimulations = 500) {
    const heroHole = playersCards[idx];
    const board = communityCards;
    const known = [...heroHole, ...board];
    const fullDeck = createDeck();
    const remaining = fullDeck.filter(c =>
      !known.some(k => k.rank === c.rank && k.suit === c.suit)
    );
    const neededCommunity = 5 - board.length;
    const cardsPerOpponent = 2;
    const neededTotal = neededCommunity + numOpponents * cardsPerOpponent;
    if (neededTotal <= 0 || neededTotal > remaining.length) return 0.0;

    let wins = 0;
    let ties = 0;
    for (let sim = 0; sim < numSimulations; sim++) {
      const sample = [];
      const tempDeck = [...remaining];
      for (let i = 0; i < neededTotal; i++) {
        const j = Math.floor(Math.random() * tempDeck.length);
        sample.push(tempDeck[j]);
        tempDeck.splice(j, 1);
      }
      let pos = 0;
      let futureBoard = [...board];
      if (neededCommunity > 0) {
        futureBoard = board.concat(sample.slice(pos, pos + neededCommunity));
        pos += neededCommunity;
      }
      const oppHands = [];
      for (let o = 0; o < numOpponents; o++) {
        oppHands.push(sample.slice(pos, pos + 2));
        pos += 2;
      }
      const heroBest = evaluate7cards(heroHole.concat(futureBoard));
      const oppBestList = oppHands.map(h => evaluate7cards(h.concat(futureBoard)));
      let bestOpp = oppBestList[0];
      for (let i = 1; i < oppBestList.length; i++) {
        if (compareHands(oppBestList[i], bestOpp) > 0) {
          bestOpp = oppBestList[i];
        }
      }
      const cmp = compareHands(heroBest, bestOpp);
      if (cmp > 0) wins += 1;
      else if (cmp === 0) ties += 1;
    }
    return (wins + 0.5 * ties) / numSimulations;
  }

  function aiAction(idx) {
    if (!inHand[idx] || chips[idx] <= 0) return;
    const toCall = currentBet - bets[idx];
    const opponents = inHand.filter((v, i) => v && i !== idx).length;
    const statusElem = playerElements(idx).status;

    if (opponents <= 0) {
      if (toCall > 0) {
        takeBet(idx, toCall);
        statusElem.textContent = "çŠ¶æ€ï¼šè·Ÿæ³¨ï¼ˆæ— å¯¹æ‰‹ï¼‰";
      } else {
        statusElem.textContent = "çŠ¶æ€ï¼šè¿‡ç‰Œ";
      }
      return;
    }

    const winProb = estimateWinProbability(idx, opponents, 80);

    if (toCall <= 0) {
      if (winProb > 0.7 && chips[idx] > 0) {
        const baseBet = Math.max(BIG_BLIND, Math.floor(pot * 0.5));
        const betAmount = Math.min(baseBet, chips[idx]);
        if (betAmount > 0) {
          statusElem.textContent = `çŠ¶æ€ï¼šä¸»åŠ¨ä¸‹æ³¨ ${betAmount}ï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
          currentBet = currentBet + betAmount;
          takeBet(idx, betAmount);
        } else {
          statusElem.textContent = `çŠ¶æ€ï¼šè¿‡ç‰Œï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
        }
      } else if (winProb > 0.45) {
        statusElem.textContent = `çŠ¶æ€ï¼šè¿‡ç‰Œï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
      } else {
        statusElem.textContent = `çŠ¶æ€ï¼šè¿‡ç‰Œï¼ˆå¼±ç‰Œï¼Œèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
      }
    } else {
      const potAfterCall = pot + toCall;
      const potOdds = potAfterCall > 0 ? (toCall / potAfterCall) : 1.0;
      if (winProb < potOdds * 0.8) {
        inHand[idx] = false;
        statusElem.textContent = `çŠ¶æ€ï¼šå¼ƒç‰Œï¼ˆèƒœç‡ ${winProb.toFixed(2)} < å½©æ± èµ”ç‡ ${potOdds.toFixed(2)}ï¼‰`;
        return;
      }
      takeBet(idx, toCall);
      const canRaise = chips[idx] > BIG_BLIND;
      if (winProb > potOdds * 1.5 && canRaise) {
        const extra = Math.min(
          Math.max(BIG_BLIND, Math.floor(pot * 0.3)),
          chips[idx]
        );
        if (extra > 0) {
          currentBet = currentBet + extra;
          takeBet(idx, extra);;
          statusElem.textContent = `çŠ¶æ€ï¼šè·Ÿæ³¨å¹¶åŠ æ³¨ ${extra}ï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
        } else {
          statusElem.textContent = `çŠ¶æ€ï¼šè·Ÿæ³¨ï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼‰`;
        }
      } else {
        statusElem.textContent = `çŠ¶æ€ï¼šè·Ÿæ³¨ï¼ˆèƒœç‡ ${winProb.toFixed(2)}ï¼Œä¸é€‚åˆåŠ æ³¨ï¼‰`;
      }
    }
  }

  function afterPlayerAction() {
  // è®©æ‰€æœ‰ AI è¡ŒåŠ¨ä¸€è½®
  for (let i = 1; i < NUM_PLAYERS; i++) {
    if (!inHand[i] || chips[i] <= 0) continue;
    aiAction(i);
  }

  const alive = inHand.map((v, i) => v ? i : -1).filter(i => i >= 0);

  if (alive.length === 1) {
    awardPot([alive[0]]);
    const who = alive[0] === 0 ? "Kai" : `ç©å®¶${alive[0] + 1}`;
    setStatusBar(`æ‰€æœ‰äººå¼ƒç‰Œï¼Œ${who} ç›´æ¥èµ¢å¾—åº•æ± ã€‚`);
    endHand();
    return;
  }

  const toCallNow = currentBet - bets[0];

  if (inHand[0] && toCallNow > 0) {
    // AI åŠ æ³¨äº†ï¼Œç©å®¶1éœ€è¦å†æ¬¡è¡ŒåŠ¨ï¼Œä¸è¿›å…¥ä¸‹ä¸€è¡—
    qs('#btnCall').textContent = `è·Ÿæ³¨ ${toCallNow}`;
    enableActionButtons(true);
    setStatusBar(`æœ‰ç©å®¶åŠ æ³¨ï¼Œéœ€è·Ÿæ³¨ ${toCallNow}ï¼Œè¯·é€‰æ‹©æ“ä½œã€‚`);
    return;
  }

  qs('#btnCall').textContent = `çœ‹ç‰Œ`;

  if (street === "river") {
    revealRemainingBoard();
    doShowdown();
    return;
  } 
else if (street === "turn") {
  advanceStreet();
} else if (street === "flop") {
  advanceStreet();
} else if (street === "preflop") {
  advanceStreet();
}

  // ---------- äº‹ä»¶ç»‘å®š & åˆå§‹åŒ– ----------

  qs('#newRoundBtn').addEventListener('click', newRound);
  qs('#btnCall').addEventListener('click', actionCallOrCheck);
  qs('#btnRaise').addEventListener('click', actionRaise);
  qs('#btnFold').addEventListener('click', actionFold);

  function initEmptyUI() {
    communityCards = [];
    renderCommunity();
    renderPlayers();
    enableActionButtons(false);
  }

  document.addEventListener('DOMContentLoaded', initEmptyUI);
</script>
</body>
</html>
